package org.cdlib.mrt.zk;

import java.util.List;

import org.apache.zookeeper.KeeperException;
import org.apache.zookeeper.ZooKeeper;
import org.json.JSONObject;

/**
 * Class to manage a Merritt Ingest Batch in the Batch Queue.
 * @see <a href="https://github.com/CDLUC3/mrt-doc/blob/main/design/queue-2023/transition.md">State Transition Design</a>
 */
public class Batch extends QueueItem {
  public static final String DIR = "/batches";
  public static final String PREFIX = "bid";
  private boolean hasFailure = false;

  /**
   * @param id Unique id assigned to a batch.  This id is generated by creating a sequential batch folder.
   */
  public Batch(String id) {
    super(id);
  }

  /**
   * @param id Unique id assigned to a batch.  This id is generated by creating a sequential batch folder.
   * @param data JSON representation of an ingest initiated by a Merritt depostor.
   */
  public Batch(String id, JSONObject data) {
    super(id, data);
  }

  /**
   * Indicate that a batch contains a failed job in the Job Queue.
   */
  public boolean hasFailure() {
    return this.hasFailure;
  }

  public String dir() {
    return Batch.DIR;
  }
  public String prefix() {
    return Batch.PREFIX;
  }
  public static String prefixPath() {
    return String.format("%s/%s", Batch.DIR, Batch.PREFIX);
  };
  public static IngestState initStatus() {
    return BatchState.Pending;
  }

  public void loadHasFailure(ZooKeeper client) throws KeeperException, InterruptedException {
    this.hasFailure = false;
    String p = String.format("%s/states/batch-failed", path());
    if (QueueItemHelper.exists(client, p)) {
      if (!client.getChildren(p, false).isEmpty()) {
        this.hasFailure = true;
      }
    }
  }

  public IngestState resolveStatus(String s){
    return BatchState.valueOf(s);
  }

  @Override
  public void loadProperties(ZooKeeper client) throws KeeperException, InterruptedException {
    loadHasFailure(client);
  }

  public IngestState[] states() {
    return BatchState.values();
  }

  public static Batch createBatch(ZooKeeper client, JSONObject submission) throws KeeperException, InterruptedException, MerrittZKNodeInvalid {
    String id = QueueItemHelper.createId(client, Batch.prefixPath());
    Batch batch = new Batch(id, submission);
    batch.createData(client, ZKKey.BATCH_SUBMISSION, submission);
    batch.setStatus(client, Batch.initStatus()); 
    return batch;
  }

  public void delete(ZooKeeper client) throws MerrittStateError, MerrittZKNodeInvalid, KeeperException, InterruptedException {
    String[] dirs = {"batch-processing", "batch-failed", "batch-completed"};
    if (!this.status().isDeletable()) {
      throw new MerrittStateError(String.format("Delete invalid for %s", path()));
    }
    for(String state: dirs) {
      String p = String.format("%s/states/%s", path(), state);
      if (QueueItemHelper.exists(client, p)) {
        for(String cp: client.getChildren(p, false)) {
          new Job(cp, id()).load(client).delete(client);
        }
      }
    }

    QueueItemHelper.deleteAll(client, path());
  }

  public static Batch acquirePendingBatch(ZooKeeper client) throws MerrittZKNodeInvalid, KeeperException, InterruptedException {
    List<String> batches = client.getChildren(Batch.DIR, false);
    batches.sort(String::compareTo);
    for(String cp: batches) {
      String p = String.format("%s/%s/states", Batch.DIR, cp);
      if (!QueueItemHelper.exists(client, p)) {
        Batch b = new Batch(cp);
        if (b.lock(client)) {
          b.load(client);
          b.createData(client, ZKKey.STATES, null);
          return b;
        }
      }
    }  
    return null;
  }
  public static Batch acquireCompletedBatch(ZooKeeper client) throws MerrittZKNodeInvalid, KeeperException, InterruptedException {
    List<String> batches = client.getChildren(Batch.DIR, false);
    batches.sort(String::compareTo);
    for(String cp: batches) {
      String p = String.format("%s/%s/states/batch-processing", Batch.DIR, cp);
      if (QueueItemHelper.exists(client, p)) {
        if (client.getChildren(p, false).isEmpty()) {
          Batch b = new Batch(cp);
          if (b.lock(client)) {
            b.load(client);
            b.setStatus(client, BatchState.Reporting);
            return b;
          }
        }
      }
    }  
    return null;
  }  

  public static void main(String[] argv){
    System.out.println("Batch States");
  }
}
