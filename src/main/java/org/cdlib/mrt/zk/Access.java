package org.cdlib.mrt.zk;

import java.nio.file.Paths;
import java.util.List;

import org.apache.zookeeper.KeeperException;
import org.apache.zookeeper.ZooKeeper;
import org.json.JSONObject;

/**
 * Class to manage a Merritt Access Assembly Request.
 * @see <a href="https://github.com/CDLUC3/mrt-zk/blob/main/design/transition.md">State Transition Design</a>
 */
public class Access extends QueueItem {
  /**
   * Access Assembly Queue names
   */
  public static enum Queues {small, large;}

  private Queues queueName;

  /**
   * @param queueName indicates large or small access queue
   * @param id Unique id assigned to an assembly request.  This id is generated by creating a sequential queue item.
   */
  public Access(Queues queueName, String id) {
    super(id);
    this.queueName = queueName;
  }

  /**
   * @param queueName indicates large or small access queue
   * @param id Unique id assigned to an assembly request.  This id is generated by creating a sequential item.
   * @param data JSON representation of an ingest initiated by a Merritt depostor.
   */
  public Access(Queues queueName, String id, JSONObject data) {
    super(id, data);
    this.queueName = queueName;
  }

  public static String dir(Queues queueName) {
    return Paths.get(QueueItem.ZkPaths.Access.path, queueName.name()).toString();
  }

  public String dir() {
    return Access.dir(queueName);
  }
  public String prefix() {
    return QueueItem.ZkPrefixes.Access.prefix;
  }
  public static String prefixPath(Queues queueName) {
    return String.format("%s/%s", Access.dir(queueName), QueueItem.ZkPrefixes.Access.prefix);
  };
  public static IngestState initStatus() {
    return AccessState.Pending;
  }

  public IngestState resolveStatus(String s){
    return AccessState.valueOf(s);
  }

  @Override
  public void loadProperties(ZooKeeper client) throws KeeperException, InterruptedException, MerrittZKNodeInvalid {
    data = optJsonProperty(client, ZKKey.ACCESS_TOKEN);
  }

  public String token() {
    return jsonStringProperty(data, MerrittJsonKey.AccessToken, "");
  }
  public int deliveryNode() {
    return jsonIntProperty(data, MerrittJsonKey.AccessDeliveryNode, 0);
  }
  public long cloudContentByte() {
    return jsonLongProperty(data, MerrittJsonKey.AccessCloudContentByte, 0);
  }
  public String tokenStatus() {
    return jsonStringProperty(data, MerrittJsonKey.AccessTokenStatus, "");
  }
  public String url() {
    return jsonStringProperty(data, MerrittJsonKey.AccessUrl, "");
  }
  public String anticipatedAvailabilityTime() {
    return jsonStringProperty(data, MerrittJsonKey.AccessAnticipatedAvailabilityTime, "");
  }

  public IngestState[] states() {
    return AccessState.values();
  }

  public static Access createAssembly(ZooKeeper client, Queues queueName, JSONObject token) throws KeeperException, InterruptedException, MerrittZKNodeInvalid {
    String id = QueueItemHelper.createId(client, Access.prefixPath(queueName));
    Access access = new Access(queueName, id, token);
    access.createData(client, ZKKey.ACCESS_TOKEN, token);
    access.setStatus(client, Access.initStatus()); 
    return access;
  }

  public void delete(ZooKeeper client) throws MerrittStateError, MerrittZKNodeInvalid, KeeperException, InterruptedException {
    if (!this.status().isDeletable()) {
      throw new MerrittStateError(String.format("Delete invalid for %s", path()));
    }
    QueueItemHelper.deleteAll(client, path());
  }

  public static Access acquirePendingAssembly(ZooKeeper client, Queues queueName) throws MerrittZKNodeInvalid, KeeperException, InterruptedException {
    List<String> assemblies = client.getChildren(Access.dir(queueName), false);
    assemblies.sort(String::compareTo);
    for(String cp: assemblies) {
      Access a = new Access(queueName, cp);
      if (a != null) {
        a.load(client);
        if (a.status() == AccessState.Pending) {
          if (a.lock(client)) {
            a.load(client);
            return a;
          }
        }
      }
    }  
    return null;
  }

  public static void initNodes(ZooKeeper client) throws KeeperException, InterruptedException {
    QueueItemHelper.createIfNeeded(client, QueueItem.ZkPaths.Access.path);
    QueueItemHelper.createIfNeeded(client, QueueItem.ZkPaths.AccessSmall.path);
    QueueItemHelper.createIfNeeded(client, QueueItem.ZkPaths.AccessLarge.path);
  }
}
